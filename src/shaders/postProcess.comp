#version 460 core

layout(local_size_x = 16, local_size_y = 8, local_size_z = 1) in;
layout(rgba16f, binding = 0) uniform image2D currentFrame;
layout(rgba16f, binding = 1) uniform image2D postProcessOutput;
layout(rgba16f, binding = 2) uniform readonly image2D envCubemap;

float linear_rgb_to_srgb(float color) // took it from blender's source code
{
	if(color < 0.0031308)
	{
		return (color < 0.0) ? 0.0 : color * 12.92;
	}

	return 1.055 * pow(color, 1.0 / 2.4) - 0.055;
}

vec3 reinahrd(vec3 color)
{
	// Reinhard tonemapping
	return color / (color + vec3(1.0));
}

vec3 uncharted(vec3 color)
{
	// Uncharted 2 tonemapping
	float A = 0.15;
	float B = 0.50;
	float C = 0.10;
	float D = 0.20;
	float E = 0.02;
	float F = 0.30;
	float W = 11.2;

	vec3 uncharted = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;
	float whiteScale = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;
	return uncharted / whiteScale;
}

vec3 aces(vec3 color)
{
	// ACES approximation
	return color * (2.51 * color + 0.03) / (color * (2.43 * color + 0.59) + 0.14);
}

void main()
{
	
	vec3 background = imageLoad(envCubemap, ivec2(gl_GlobalInvocationID.xy)).rgb;
	background = aces(background); // reinhard, uncharted, or aces
	background = vec3(linear_rgb_to_srgb(background.r), linear_rgb_to_srgb(background.g), linear_rgb_to_srgb(background.b));

	vec3 color = imageLoad(currentFrame, ivec2(gl_GlobalInvocationID.xy)).rgb;
	color = aces(color); // reinhard, uncharted, or aces
	color = vec3(linear_rgb_to_srgb(color.r), linear_rgb_to_srgb(color.g), linear_rgb_to_srgb(color.b));
	float alpha = imageLoad(currentFrame, ivec2(gl_GlobalInvocationID.xy)).a; // Assuming depth is stored in alpha channel

	vec3 outColor = vec3(0.0);
	if (alpha > 0.000001) // If alpha is very low, use background color
	{
		outColor = color;
	}
	else
	{
		outColor = background;
	}
	imageStore(postProcessOutput, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0));
}