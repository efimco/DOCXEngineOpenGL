#version 460 core

layout(local_size_x = 16, local_size_y = 8, local_size_z = 1) in;

layout(rgba16f, binding = 0) uniform readonly image2D currentFrame;
layout(rgba16f, binding = 1) uniform readonly image2D historyFrame;
layout(rgba16f, binding = 2) uniform writeonly image2D outputFrame;
layout(rg16f, binding = 3) uniform readonly image2D velocityTexture;
layout(r32f, binding = 4) uniform readonly image2D depthTexture;
layout(r32f, binding = 5) uniform readonly image2D prevDepthTexture;

uniform int isTAA;
uniform int historyValid;
uniform int frameNumber;
uniform int useBicubicSampling;
uniform int usePostSharpening;
uniform vec2 cameraJitter;
uniform vec2 prevCameraJitter;



vec4 AdjustHDRColor(vec3 color)
{

	// float luminance = dot(color, vec3(0.299, 0.587, 0.114));
	// float luminanceWeight = 1.0 / (1.0 + luminance);
	// return vec4(color, 1.0) * luminanceWeight;

	return vec4(mix(vec3(-10.0), log(color), step(vec3(0.0), color)), 1.0); // Guard against nan

	// return vec4(color, 1.0); // For non-HDR, just return the color as is

}


vec2 GetVelocity(ivec2 uv)
{
	ivec2 texSize = imageSize(velocityTexture).xy;
	float closestDepth = 100.0;
	ivec2 closestUVOffset = ivec2(0);
	for(int j = -2; j <= 2; ++j)
	{
		for(int i = -2; i <= 2; ++i)
		{
			
			ivec2 uvOffset = ivec2(round(ivec2(i, j) / texSize));
			
			float neighborDepth = imageLoad(depthTexture, uv + uvOffset).r;
			if(neighborDepth < closestDepth)
			{
				closestUVOffset = uvOffset;
				closestDepth = neighborDepth;
			}
		}
	}
	return imageLoad(velocityTexture, uv + closestUVOffset).rg;
}


void main()
{
	ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
	ivec2 texSize = imageSize(currentFrame).xy;
	
	vec4 currentColor = AdjustHDRColor(imageLoad(currentFrame, uv).rgb);
	if (isTAA == 1)
	{

		vec2 velocity = GetVelocity(uv);
		// vec2 velocity = imageLoad(velocityTexture, uv).rg;	
		ivec2 reprojectedUV = uv + ivec2(round(velocity));
		vec4 previousColor = AdjustHDRColor(imageLoad(historyFrame, reprojectedUV).rgb);


		vec4 minColor = vec4(9999.0), maxColor = vec4(-9999.0);
		for(int x = -1; x <= 1; ++x)
		{
			for(int y = -1; y <= 1; ++y)
			{	
				vec4 color = imageLoad(currentFrame, uv + ivec2(x, y));
				color = AdjustHDRColor(color.rgb); // Sample neighbor
				minColor = min(minColor, color); // Take min and max
				maxColor = max(maxColor, color);
			}
		}

		vec3 previousColorClamped = clamp(previousColor.rgb, minColor.rgb, maxColor.rgb);

		float currentWeight = 0.1 * currentColor.a;
		float previousWeight = 0.9 * previousColor.a;

		vec3 outputColor = (currentColor.rgb * currentWeight + previousColorClamped.rgb * previousWeight);
 
		// outputColor /= (currentWeight + previousWeight); // Normalize back. Note that this has no effect in the log case

		outputColor = exp(outputColor); // Undo log transformation
		// vec4 outputColor = mix(currentColor, previousColorClamped, 0.9);
		imageStore(outputFrame, uv, vec4(outputColor, 1.0));
	}
	else
	{
		currentColor = exp(currentColor);
		imageStore(outputFrame, ivec2(gl_GlobalInvocationID.xy), vec4(currentColor.rgb, 1.0));
	}
}
