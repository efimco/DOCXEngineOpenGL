#version 460 core

layout(local_size_x = 16, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) uniform sampler2D currentFrame;
layout(binding = 1) uniform sampler2D historyFrame;
layout(rgba16f, binding = 2) uniform writeonly image2D outputFrame;
layout(binding = 3) uniform sampler2D velocityTexture;
layout(binding = 4) uniform sampler2D prevVelocityTexture;
layout(binding = 5) uniform sampler2D depthTexture;
layout(binding = 6) uniform sampler2D prevDepthTexture;

uniform int isTAA;
uniform int frameNumber;
uniform vec4 resolution; // x: width, y: height, z: 1/width, w: 1/height
uniform vec2 cameraJitter;
uniform vec2 prevCameraJitter;
uniform float nearPlane;
uniform float farPlane;

void main()
{
	ivec2 st = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = (vec2(st) + 0.5) / resolution.xy; // cuz we need to sample at the center of the pixel
	vec3 currentColorSample = texture(currentFrame, uv).rgb;
	
	if (isTAA == 0)
	{
		imageStore(outputFrame, st, vec4(currentColorSample, 1.0));
		return;
	}

	//just use current frame  to establish history For the first few frames
	if (frameNumber < 2)
	{
		imageStore(outputFrame, st, vec4(currentColorSample, 1.0));
		return;
	}

	
	vec2 maxVelocity = texture(velocityTexture, uv).rg;
	float maxVelocityMagnitude = length(maxVelocity);

	for(int x = -2; x <= 2; ++x)
	{
		for(int y = -2; y <= 2; ++y)
		{
			vec2 neighborUV = uv + vec2(x, y) * resolution.zw;
			vec2 neighborVelocity = texture(velocityTexture, neighborUV).rg;
			float neighborMagnitude = length(neighborVelocity);
			
			if(neighborMagnitude > maxVelocityMagnitude)
			{
				maxVelocity = neighborVelocity;
				maxVelocityMagnitude = neighborMagnitude;
			}
		}
	}

	vec2 reprojectedUV = uv + maxVelocity; 

	vec3 historyColorSample = texture(historyFrame, reprojectedUV).rgb;
		
	if (maxVelocityMagnitude > 0.1) // Large motion, potentially a camera cut
	{
		imageStore(outputFrame, st, vec4(currentColorSample, 1.0));
		return;	
	}

	
	// Check if reprojection is within bounds
	if ( any(lessThan(reprojectedUV, vec2(0.0))) || any(greaterThan(reprojectedUV, vec2(1.0))) )
	{
		imageStore(outputFrame, st, vec4(currentColorSample, 1.0));
		return;
	}

	vec3 minColor = vec3(9999.0), maxColor = vec3(-9999.0);

	// neighborhood bounding box
	for(int x = -1; x <= 1; ++x)
	{
		for(int y = -1; y <= 1; ++y)
		{	
			vec2 neighborUV = uv + vec2(x, y) * resolution.zw; 
			vec3 color = texture(currentFrame, neighborUV).rgb;
			minColor = min(minColor, color); 
			maxColor = max(maxColor, color);
		}
	}

	historyColorSample = clamp(historyColorSample, minColor, maxColor);
	

	vec3 colorVariance = maxColor - minColor;
	float variance = dot(colorVariance, vec3(1.0)) / 3.0; // average variance across RGB channels
	
	// if variance is high - more of current frame usage
	float blendFactor = mix(0.95, 0.7, smoothstep(0.0, 0.1, variance));
	
	vec3 outputColor = mix(currentColorSample, historyColorSample, blendFactor);
	imageStore(outputFrame, st, vec4(outputColor, 1.0));
}
